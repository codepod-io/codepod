// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator studio-client {
  provider      = "prisma-client-js"
  binaryTargets = ["native"]
}

model Post {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
}

model Profile {
  id     String  @id @default(uuid())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId String  @unique
}

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  username       String   @unique
  name           String?
  hashedPassword String
  posts          Post[]
  profile        Profile?
  Repo           Repo[]
}

model Repo {
  id     String   @id @default(uuid())
  name   String
  // fullname String  @unique
  owner  User     @relation(fields: [userId], references: [id])
  userId String
  pods   Pod[]    @relation("BELONG")
  podsId String[]

  @@unique([name, userId])
}

enum PodType {
  CODE
  DECK
  WYSIWYG
  MD
  REPL
}

model Pod {
  id       String  @id @default(uuid())
  parent   Pod?    @relation("PARENT", fields: [parentId], references: [id])
  parentId String?
  index    Int
  // TODO how to specify the order of children
  //
  // Option 1:
  // https://stackoverflow.com/questions/11094338/storing-item-positions-for-ordering-in-a-database-efficiently
  // I can store a (position, timestamp). To udpate, just move the position, and
  // use a new timestamp. The newer timestamp will ensure the correct order.
  //
  // What about
  // - addition: OK
  // - deletion: OK
  // - deletion + insertion: seems OK
  //
  //
  // Option 2:
  // https://softwareengineering.stackexchange.com/questions/304593/how-to-store-ordered-information-in-a-relational-database
  // Another option is to maintain the order of the pod, then, update all other
  // pods after it.
  children Pod[]   @relation("PARENT")
  content  String?
  // the HEAD version and STAGED version of pod content
  githead  String?
  staged   String?
  column   Int @default(1)
  fold     Boolean @default(false)
  thundar  Boolean @default(false)
  utility  Boolean @default(false)
  name     String?
  lang     String?
  type     PodType
  result   String?
  stdout   String?
  error    String?
  imports  String?
  exports  String?
  midports String?
  // repo        Repo?    @relation("ROOT")
  repo     Repo    @relation("BELONG", fields: [repoId], references: [id])

  repoId String
  // this is just a place holder. Not useful
}

// model Deck {
//   id         String       @id @default(uuid())
//   children   Pod[]
//   Repo       Repo[]
//   DeckOrDock DeckOrDock[]
// }

// model Pod {
//   id      String @id @default(uuid())
//   parent  Deck   @relation(fields: [deckId], references: [id])
//   deckId  String
//   content String
// }
